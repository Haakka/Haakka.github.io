{"meta":{"title":"Hakka的个人博客","subtitle":"记录学习历程","description":"这是一个Java从业者的个人博客，内容不定看心情，学到啥写啥~想啥写啥~","author":"Hakka","url":"https://haakka.github.io","root":"/"},"pages":[{"title":"","date":"2019-03-23T07:54:13.000Z","updated":"2019-03-23T08:42:35.735Z","comments":true,"path":"404/index.html","permalink":"https://haakka.github.io/404/index.html","excerpt":"","text":"&lt;!DOCTYPE html&gt; 404"},{"title":"about","date":"2019-03-23T08:04:54.000Z","updated":"2019-03-23T08:04:54.112Z","comments":true,"path":"about/index.html","permalink":"https://haakka.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-03-23T08:04:35.000Z","updated":"2019-03-23T08:04:35.635Z","comments":true,"path":"categories/index.html","permalink":"https://haakka.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-03-23T08:04:28.000Z","updated":"2019-03-23T08:04:28.551Z","comments":true,"path":"tags/index.html","permalink":"https://haakka.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2018-02-18T02:35:16.000Z","updated":"2019-03-25T12:08:52.522Z","comments":true,"path":"2018/02/18/hello-world/","link":"","permalink":"https://haakka.github.io/2018/02/18/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"第一篇文章测试","slug":"First","date":"2018-02-17T04:35:16.000Z","updated":"2019-03-25T12:08:54.333Z","comments":true,"path":"2018/02/17/First/","link":"","permalink":"https://haakka.github.io/2018/02/17/First/","excerpt":"","text":"写作介绍1，字体介绍这是斜体 或 这也是斜体这是粗体这是加粗斜体这是删除线 2，分级标题一级标题二级标题三级标题四级标题五级标题六级标题3，超链接写法： 行内形式：我的博客参考形式：[我的博客][1]，有一个很好的平台-[简书][2][1]:https://Haakka.github.io/自动链接：我的博客地址https://Haakka.github.io/ 4,列表无序列表：写法： 无序列表项1 无序列表项2 无序列表项3s有序列表：写法：1.有序列表项12.有序列表项23.有序列表项3 5，插入图片在 Hexo 中插入图片，需要将图片放在 source/img/ 文件夹下 6，表格 表头1 表头2 表头3 表头4 默认左对齐 左对齐 居中对其 右对齐 默认左对齐 左对齐 居中对其 右对齐 默认左对齐 左对齐 居中对其 右对齐","categories":[],"tags":[{"name":"test","slug":"test","permalink":"https://haakka.github.io/tags/test/"}]},{"title":"HashMap总结篇","slug":"HashMap","date":"2017-12-25T12:07:30.000Z","updated":"2019-03-26T12:59:35.760Z","comments":true,"path":"2017/12/25/HashMap/","link":"","permalink":"https://haakka.github.io/2017/12/25/HashMap/","excerpt":"","text":"名词解释：散列表（Hash table，又称哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。 Map(JDK文档)：An object that maps keys to values. A map cannot contain duplicate keys; each key can map to at most one value.（将键映射到值的对象。不能包含重复的键;每个键最多可以映射一个值。） HashMap概念HashMap 是一个散列表，它存储的内容是键值对(key-value)映射，继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口。 1.Map 接口的实现提供所有可选的映射操作，并允许使用 null 值和 null 键。（除了不同步和允许使用 null 之外，HashMap 类与 Hashtable 大致相同。）此类不保证映射的顺序，特别是它不保证该顺序恒久不变。另外，HashMap是非线程安全的，也就是说在多线程的环境下，可能会存在问题，而Hashtable是线程安全的。 2.Map 接口的实现假定哈希函数将元素正确分布在各桶之间，可为基本操作（get 和 put）提供稳定的性能。迭代集合视图所需的时间与 HashMap 实例的“容量”（桶的数量）及其大小（键-值映射关系数）的和成比例。所以，如果迭代性能很重要，则不要将初始容量设置得太高（或将加载因子设置得太低）。 HashMap 的实例有两个参数影响其性能：初始容量和加载因子。 容量是哈希表中桶的数量，初始容量只是哈希表在创建时的容量。 加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度。 当哈希表中的条目数超出了加载因子与当前容量的乘积时，通过调用 rehash 方法将容量翻倍。通常，默认加载因子 (0.75) 在时间和空间成本上寻求一种折衷。加载因子过高虽然减少了空间开销，但同时也增加了查询成本（在大多数 HashMap 类的操作中，包括 get 和 put 操作，都反映了这一点）。所以在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便最大限度地降低 rehash 操作次数。如果初始容量大于最大条目数乘以加载因子，则不会发生 rehash 操作。 HashMap结构JDK1.8之前，HashMap采用数组+链表实现，即使用链表处理冲突，同一hash值的节点都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。 JDK1.8之前 HashMap结构如上图JDK1.8中，HashMap采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树。 JDK1.8 HashMap结构如上图 Q：JDK1.8中HashMap为什么要引入红黑树？A: 数组的优点是：物理地址连续 + 按下标随机访问效率高O(1)，缺点是插入，删除效率低；链表的优点是存储地址不连续，可灵活的扩展自己的长度，插入，删除效率高，但是访问效率低O(n)。所以当 HashMap 中有大量的元素都存放到同一个桶中时，这个桶下有一条长长的链表，这个时候 HashMap 就相当于一个单链表，假如单链表有 n 个元素，遍历的时间复杂度就是 O(n)，而红黑树的时间复杂是O(logn)，大大的提高了查找速度。 Q：JDK1.8中HashMap为什么当链表长度大于8时才转换成红黑树呢？A: 因为红黑树的时间复杂是O(logn），长度为8的时候，平均查找长度为3。如果继续使用链表，平均查找长度为8/2=4。这才有转换为树的必要。。链表长度如果是6以内，6/2=3，速度也很快的。转化为树还有生成树的时间，并不明智。长度为8，链表转树，长度为6，树转链表，中间有个差值，可以防止链表和树频繁转换。假设8以上转为树，8以下转为链表，那么Hashmap如果不停的插入删除，链表长度在8左右徘徊，就会不停的树转链表，链表转树，就会效率很低。","categories":[],"tags":[{"name":"HashMap","slug":"HashMap","permalink":"https://haakka.github.io/tags/HashMap/"}]}]}